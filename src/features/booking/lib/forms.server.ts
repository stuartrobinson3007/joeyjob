import { createServerFn } from '@tanstack/react-start'
import { eq, and, sql, isNull, isNotNull } from 'drizzle-orm'
import { z } from 'zod'
import { customAlphabet } from 'nanoid'

import { organizationMiddleware } from '@/features/organization/lib/organization-middleware'
import { db } from '@/lib/db/db'
import { bookingForms, organization, subscription } from '@/database/schema'
import { AppError } from '@/taali/utils/errors'
import { ERROR_CODES } from '@/taali/errors/codes'
import { APP_ERROR_CODES } from '@/lib/errors/app-error-codes'

// Custom ID generator for forms: 12 characters, lowercase letters and numbers only
const generateFormId = customAlphabet('0123456789abcdefghijklmnopqrstuvwxyz', 12)

// Utility function to generate slugs
function generateSlug(text: string): string {
  return text
    .toLowerCase()
    .trim()
    .replace(/[^a-z0-9\s-]/g, '') // Remove special characters except spaces and hyphens
    .replace(/\s+/g, '-') // Replace spaces with hyphens
    .replace(/-+/g, '-') // Replace multiple hyphens with single hyphen
    .replace(/^-+|-+$/g, '') // Remove leading/trailing hyphens
    || 'form' // Fallback if empty
}

// Validation schemas
const createFormSchema = z.object({
  name: z.string().min(1, 'Form name is required').default('Untitled Form'),
}).default({
  name: 'Untitled Form',
})

const updateFormSchema = z.object({
  id: z.string(),
  name: z.string().optional(),
  slug: z.string().optional(),
  formConfig: z.any().optional(), // Form editor configuration JSON
  theme: z.enum(['light', 'dark']).optional(),
  primaryColor: z.string().optional(),
  isActive: z.boolean().optional(),
})


const deleteFormSchema = z.object({
  id: z.string(),
})

// Create a new form (like createTodo pattern)
export const createForm = createServerFn({ method: 'POST' })
  .middleware([organizationMiddleware])
  .validator((data: unknown) => {
    console.log('📝 createForm validator received:', data)
    try {
      const result = createFormSchema.parse(data || {})
      console.log('📝 createForm validation successful:', result)
      return result
    } catch (error) {
      console.error('❌ createForm validation failed:', error)
      throw error
    }
  })
  .handler(async ({ data, context }) => {
    const { organizationId, user } = context
    console.log('📝 createForm handler received:', { data, organizationId, userId: user.id })
    
    // No permission checks needed - organization middleware ensures user is member

    try {
      console.log('📝 Creating default form configuration...')
      // Create default form configuration in normalized format
      const defaultConfig = {
        id: '', // Will be set to the form ID after creation
        name: data.name,
        slug: '', // Will be set to the form ID after creation
        theme: 'light' as const,
        primaryColor: '#3B82F6',
        nodes: {
          'root': {
            id: 'root',
            type: 'root' as const,
            parentId: null,
            title: 'Book your service',
            childIds: []
          }
        },
        questions: {},
        baseQuestions: [
          {
            id: 'contact-info-field',
            name: 'contact_info',
            label: 'Contact Information',
            type: 'contact-info' as const,
            fieldConfig: {
              firstNameRequired: true,
              lastNameRequired: true,
              emailRequired: true,
              phoneRequired: true,
              companyRequired: false
            }
          }
        ],
        rootId: 'root',
        isDirty: false,
        lastSaved: new Date()
      }

      console.log('📝 Creating form in database with transaction...')
      
      // Use a transaction to ensure both INSERT and UPDATE succeed or fail together
      const result = await db.transaction(async (tx) => {
        // The ID will be auto-generated by the database using our custom function
        const form = await tx
          .insert(bookingForms)
          .values({
            organizationId,
            name: data.name,
            slug: '', // Temporary placeholder, will update after insertion
            formConfig: defaultConfig,
            theme: 'light',
            primaryColor: '#3B82F6',
            isActive: false, // Start as inactive until configured
            isDefault: false,
            createdBy: user.id,
          })
          .returning()

        // Update the slug and formConfig with the generated ID
        if (form[0]) {
          // Update the config with the actual form ID
          const updatedConfig = {
            ...defaultConfig,
            id: form[0].id,
            slug: form[0].id
          }

          const updatedForm = await tx
            .update(bookingForms)
            .set({
              slug: form[0].id,
              formConfig: updatedConfig
            })
            .where(eq(bookingForms.id, form[0].id))
            .returning()

          return updatedForm[0]
        }

        return form[0]
      })
      
      console.log('📝 Form created successfully:', result)
      return result
    } catch (error) {
      console.error('❌ Database operation failed:', error)
      throw new AppError(
        ERROR_CODES.SYS_SERVER_ERROR,
        500,
        undefined,
        'Failed to create form'
      )
    }
  })

// Update form (auto-save pattern)
export const updateForm = createServerFn({ method: 'POST' })
  .middleware([organizationMiddleware])
  .validator((data: unknown) => updateFormSchema.parse(data))
  .handler(async ({ data, context }) => {
    const { organizationId, user, headers } = context

    // No permission checks needed - organization middleware ensures user is member

    try {
      // Check if form exists and belongs to organization
      const existingForm = await db
        .select()
        .from(bookingForms)
        .where(and(
          eq(bookingForms.id, data.id),
          eq(bookingForms.organizationId, organizationId),
          isNull(bookingForms.deletedAt)
        ))
        .limit(1)

      if (!existingForm.length) {
        throw AppError.notFound('Form')
      }

      // If trying to enable the form, check subscription status
      if (data.isActive === true && !existingForm[0].isActive) {
        console.log(`🔍 [updateForm] Attempting to enable form ${data.id} for org ${organizationId}`)

        // Get subscription status for the organization
        const [org] = await db
          .select()
          .from(organization)
          .where(eq(organization.id, organizationId))
          .limit(1)

        console.log(`🔍 [updateForm] Organization plan check:`, {
          orgId: organizationId,
          currentPlan: org?.currentPlan,
          stripeCustomerId: org?.stripeCustomerId
        })

        // Check subscription in database
        const subscriptionRecords = await db
          .select()
          .from(subscription)
          .where(eq(subscription.referenceId, organizationId))

        console.log(`🔍 [updateForm] Subscription records found:`, {
          count: subscriptionRecords.length,
          subscriptions: subscriptionRecords.map(sub => ({
            id: sub.id,
            status: sub.status,
            plan: sub.plan,
            stripeSubscriptionId: sub.stripeSubscriptionId
          }))
        })

        // Find active subscription
        const activeSubscription = subscriptionRecords.find(
          sub => sub.status === 'active' || sub.status === 'trialing'
        )

        console.log(`🔍 [updateForm] Active subscription check:`, {
          activeSubscriptionFound: !!activeSubscription,
          activeSubscriptionStatus: activeSubscription?.status,
          activeSubscriptionId: activeSubscription?.id
        })

        if (!activeSubscription) {
          console.log(`❌ [updateForm] No active subscription found - blocking form enable`)
          // Return error with flag for frontend to show subscription dialog
          throw new AppError(
            ERROR_CODES.BIZ_SUBSCRIPTION_REQUIRED,
            403,
            { requiresSubscription: true },
            'An active subscription is required to enable booking forms'
          )
        }

        console.log(`✅ [updateForm] Active subscription found - allowing form enable`)
      }

      // Prepare update data
      const updateData: any = { updatedAt: new Date() }
      if (data.name !== undefined) updateData.name = data.name
      if (data.slug !== undefined) updateData.slug = data.slug
      if (data.formConfig !== undefined) updateData.formConfig = data.formConfig
      if (data.theme !== undefined) updateData.theme = data.theme
      if (data.primaryColor !== undefined) updateData.primaryColor = data.primaryColor
      if (data.isActive !== undefined) updateData.isActive = data.isActive

      const updatedForm = await db
        .update(bookingForms)
        .set(updateData)
        .where(eq(bookingForms.id, data.id))
        .returning()
      
      return updatedForm[0]
    } catch (error) {
      if (error instanceof AppError) throw error
      throw new AppError(
        ERROR_CODES.SYS_SERVER_ERROR,
        500,
        undefined,
        'Failed to update form'
      )
    }
  })

// Get single form by ID  
export const getForm = createServerFn({ method: 'GET' })
  .middleware([organizationMiddleware])
  .validator((data: unknown) => {
    console.log('📝 getForm validator received:', data)
    // Handle both object and string inputs
    if (typeof data === 'string') {
      return { id: data }
    }
    const result = z.object({ id: z.string() }).parse(data || {})
    console.log('📝 getForm validation result:', result)
    return result
  })
  .handler(async ({ data, context }) => {
    const { organizationId, user } = context
    
    // No permission checks needed - organization middleware ensures user is member

    try {
      const form = await db
        .select()
        .from(bookingForms)
        .where(and(
          eq(bookingForms.id, data.id),
          eq(bookingForms.organizationId, organizationId),
          isNull(bookingForms.deletedAt)
        ))
        .limit(1)

      if (!form.length) {
        throw AppError.notFound('Form')
      }

      return form[0]
    } catch (error) {
      if (error instanceof AppError) throw error
      throw new AppError(
        ERROR_CODES.SYS_SERVER_ERROR,
        500,
        undefined,
        'Failed to fetch form'
      )
    }
  })

// Delete form (soft delete)
export const deleteForm = createServerFn({ method: 'POST' })
  .middleware([organizationMiddleware])
  .validator((data: unknown) => deleteFormSchema.parse(data))
  .handler(async ({ data, context }) => {
    const { organizationId, user } = context
    
    try {
      // Check if form exists and belongs to organization
      const existingForm = await db
        .select()
        .from(bookingForms)
        .where(and(
          eq(bookingForms.id, data.id),
          eq(bookingForms.organizationId, organizationId),
          isNull(bookingForms.deletedAt)
        ))
        .limit(1)

      if (!existingForm.length) {
        throw AppError.notFound('Form')
      }

      // Soft delete: set deletedAt timestamp instead of hard delete
      await db
        .update(bookingForms)
        .set({
          deletedAt: new Date(),
          updatedAt: new Date()
        })
        .where(and(eq(bookingForms.id, data.id), eq(bookingForms.organizationId, organizationId)))

      return { success: true }
    } catch (error) {
      if (error instanceof AppError) throw error
      throw new AppError(
        ERROR_CODES.SYS_SERVER_ERROR,
        500,
        undefined,
        'Failed to delete form'
      )
    }
  })

// Undo delete form (restore from soft delete)
export const undoDeleteForm = createServerFn({ method: 'POST' })
  .middleware([organizationMiddleware])
  .validator((data: unknown) => deleteFormSchema.parse(data))
  .handler(async ({ data, context }) => {
    const { organizationId, user } = context
    
    try {
      // Check if form exists and is soft-deleted (belongs to organization)
      const existingForm = await db
        .select()
        .from(bookingForms)
        .where(and(
          eq(bookingForms.id, data.id),
          eq(bookingForms.organizationId, organizationId),
          isNotNull(bookingForms.deletedAt)
        ))
        .limit(1)

      if (!existingForm.length) {
        throw AppError.notFound('Deleted Form')
      }

      // Restore by clearing deletedAt timestamp
      const restored = await db
        .update(bookingForms)
        .set({
          deletedAt: null,
          updatedAt: new Date()
        })
        .where(and(eq(bookingForms.id, data.id), eq(bookingForms.organizationId, organizationId)))
        .returning()

      return restored[0]
    } catch (error) {
      if (error instanceof AppError) throw error
      throw new AppError(
        ERROR_CODES.SYS_SERVER_ERROR,
        500,
        undefined,
        'Failed to restore form'
      )
    }
  })

// Duplicate form
export const duplicateForm = createServerFn({ method: 'POST' })
  .middleware([organizationMiddleware])
  .validator((data: unknown) => deleteFormSchema.parse(data))
  .handler(async ({ data, context }) => {
    const { organizationId, user } = context
    
    try {
      // Check if form exists and belongs to organization
      const existingForm = await db
        .select()
        .from(bookingForms)
        .where(and(
          eq(bookingForms.id, data.id),
          eq(bookingForms.organizationId, organizationId),
          isNull(bookingForms.deletedAt)
        ))
        .limit(1)

      if (!existingForm.length) {
        throw AppError.notFound('Form')
      }

      const original = existingForm[0]
      
      // Generate new slug for the duplicate
      const baseSlug = generateSlug(`copy-of-${original.name}`)
      const slug = baseSlug + '-' + Date.now().toString(36)
      
      // Create duplicate with new name and slug
      const duplicated = await db
        .insert(bookingForms)
        .values({
          organizationId,
          name: `Copy of ${original.name}`,
          slug: slug,
          formConfig: original.formConfig,
          theme: original.theme,
          primaryColor: original.primaryColor,
          fields: original.fields, // Legacy compatibility
          serviceId: original.serviceId, // Legacy compatibility
          isActive: false, // Start as inactive
          isDefault: false, // Never duplicate as default
          createdBy: user.id,
        })
        .returning()

      return duplicated[0]
    } catch (error) {
      if (error instanceof AppError) throw error
      throw new AppError(
        ERROR_CODES.SYS_SERVER_ERROR,
        500,
        undefined,
        'Failed to duplicate form'
      )
    }
  })

// Alias for getForm to match naming convention
export const getFormById = getForm

// Get all booking forms with pagination and filtering
export const getBookingForms = createServerFn({ method: 'GET' })
  .middleware([organizationMiddleware])
  .validator((data: unknown) => {
    const schema = z.object({
      limit: z.number().min(1).max(100).default(50),
      offset: z.number().min(0).default(0),
      search: z.string().optional(),
      isActive: z.boolean().optional(),
    }).default({})
    
    if (!data || typeof data !== 'object') {
      return schema.parse({})
    }
    return schema.parse(data)
  })
  .handler(async ({ data, context }) => {
    const { organizationId } = context
    
    try {
      // Build where conditions - exclude soft-deleted forms
      const conditions = [
        eq(bookingForms.organizationId, organizationId),
        isNull(bookingForms.deletedAt)
      ]
      
      if (data.isActive !== undefined) {
        conditions.push(eq(bookingForms.isActive, data.isActive))
      }
      
      if (data.search) {
        conditions.push(
          // Search in name only
          sql`${bookingForms.name} ILIKE ${`%${data.search}%`}`
        )
      }
      
      // Get total count
      const countResult = await db
        .select({ count: sql`count(*)`.as('count') })
        .from(bookingForms)
        .where(and(...conditions))
      
      const totalCount = Number(countResult[0]?.count || 0)
      
      // Get forms with pagination
      const forms = await db
        .select()
        .from(bookingForms)
        .where(and(...conditions))
        .orderBy(bookingForms.updatedAt)
        .limit(data.limit)
        .offset(data.offset)
      
      return {
        forms: forms.map(form => ({
          form,
          service: null, // Legacy compatibility - service relationship is now in formConfig
        })),
        pagination: {
          limit: data.limit,
          offset: data.offset,
          total: totalCount,
          hasMore: data.offset + data.limit < totalCount,
        },
      }
    } catch (error) {
      console.error('❌ getBookingForms failed:', error)
      throw new AppError(
        ERROR_CODES.SYS_SERVER_ERROR,
        500,
        undefined,
        'Failed to fetch forms'
      )
    }
  })
// Get public booking form (no auth required)
export const getBookingForm = createServerFn({ method: 'GET' })
  .validator((data: unknown) => {
    const schema = z.object({
      id: z.string(),
    })
    return schema.parse(data)
  })
  .handler(async ({ data }) => {
    // Step 1: Always fetch form and organization data (regardless of isActive)
    const result = await db
      .select({
        form: bookingForms,
        organization: {
          id: organization.id,
          name: organization.name,
          slug: organization.slug,
          logo: organization.logo,
          phone: organization.phone,
          email: organization.email,
          timezone: organization.timezone
        }
      })
      .from(bookingForms)
      .innerJoin(organization, eq(bookingForms.organizationId, organization.id))
      .where(and(
        eq(bookingForms.id, data.id),
        isNull(bookingForms.deletedAt)
      ))
      .limit(1)

    // Step 2: Check if form exists at all
    if (!result.length) {
      throw new AppError(
        APP_ERROR_CODES.BIZ_FORM_NOT_FOUND,
        404,
        {
          organizationData: null,
          theme: 'light',
          primaryColor: '#3B82F6'
        },
        'Booking form not found'
      );
    }

    // Step 3: Extract theme data (always available now)
    const formData = result[0];
    const theme = formData.form.theme || 'light';
    const primaryColor = formData.form.primaryColor || '#3B82F6';

    console.log('🔍 [EMBED FORMS] Form found with theme:', {
      formId: data.id,
      isActive: formData.form.isActive,
      theme,
      primaryColor,
      orgName: formData.organization.name
    });

    // Step 4: Check if form is active
    if (!formData.form.isActive) {
      throw new AppError(
        APP_ERROR_CODES.BIZ_FORM_NOT_FOUND,
        404,
        {
          organizationData: formData.organization,
          theme,
          primaryColor
        },
        'This booking form is currently disabled'
      );
    }

    // Step 5: Check subscription (we have theme data available)
    const orgId = formData.organization.id
    const subscriptionRecords = await db
      .select()
      .from(subscription)
      .where(eq(subscription.referenceId, orgId))

    const activeSubscription = subscriptionRecords.find(
      sub => sub.status === 'active' || sub.status === 'trialing'
    )

    // If no active subscription, throw error with theme
    if (!activeSubscription) {
      throw new AppError(
        APP_ERROR_CODES.BIZ_FORM_NOT_FOUND,
        404,
        {
          subscriptionRequired: true,
          organizationData: formData.organization,
          theme,
          primaryColor
        },
        'Booking form temporarily unavailable'
      )
    }

    return {
      form: formData.form,
      organization: formData.organization,
      service: null // Legacy compatibility
    }
  })

// Get public booking form by organization slug and form slug (no auth required)
export const getBookingFormBySlug = createServerFn({ method: 'GET' })
  .validator((data: unknown) => {
    const schema = z.object({
      orgSlug: z.string(),
      formSlug: z.string(),
    })
    return schema.parse(data)
  })
  .handler(async ({ data }) => {
    // Step 1: Always fetch form and organization data (regardless of isActive)
    const result = await db
      .select({
        form: bookingForms,
        organization: {
          id: organization.id,
          name: organization.name,
          slug: organization.slug,
          logo: organization.logo,
          phone: organization.phone,
          email: organization.email,
          timezone: organization.timezone
        }
      })
      .from(bookingForms)
      .innerJoin(organization, eq(bookingForms.organizationId, organization.id))
      .where(and(
        eq(organization.slug, data.orgSlug),
        eq(bookingForms.slug, data.formSlug),
        isNull(bookingForms.deletedAt)
      ))
      .limit(1)

    // Step 2: Check if form exists at all
    if (!result.length) {
      // Truly not found - try to get organization data for contact info
      const orgResult = await db
        .select({
          id: organization.id,
          name: organization.name,
          slug: organization.slug,
          logo: organization.logo,
          phone: organization.phone,
          email: organization.email,
          timezone: organization.timezone
        })
        .from(organization)
        .where(eq(organization.slug, data.orgSlug))
        .limit(1)

      throw new AppError(
        APP_ERROR_CODES.BIZ_FORM_NOT_FOUND,
        404,
        {
          organizationData: orgResult[0] || null,
          theme: 'light',
          primaryColor: '#3B82F6'
        },
        'Booking form not found'
      );
    }

    // Step 3: Extract theme data (always available now)
    const formData = result[0];
    const theme = formData.form.theme || 'light';
    const primaryColor = formData.form.primaryColor || '#3B82F6';

    console.log('🔍 [FORMS] Form found with theme:', {
      formSlug: data.formSlug,
      isActive: formData.form.isActive,
      theme,
      primaryColor,
      orgName: formData.organization.name
    });

    // Step 4: Check if form is active
    if (!formData.form.isActive) {
      throw new AppError(
        APP_ERROR_CODES.BIZ_FORM_NOT_FOUND,
        404,
        {
          organizationData: formData.organization,
          theme,
          primaryColor
        },
        'This booking form is currently disabled'
      );
    }

    // Step 5: Check subscription (we have theme data available)
    const orgId = formData.organization.id
    const subscriptionRecords = await db
      .select()
      .from(subscription)
      .where(eq(subscription.referenceId, orgId))

    const activeSubscription = subscriptionRecords.find(
      sub => sub.status === 'active' || sub.status === 'trialing'
    )

    // If no active subscription, throw error with theme
    if (!activeSubscription) {
      throw new AppError(
        APP_ERROR_CODES.BIZ_FORM_NOT_FOUND,
        404,
        {
          subscriptionRequired: true,
          organizationData: formData.organization,
          theme,
          primaryColor
        },
        'Booking form temporarily unavailable'
      )
    }

    console.log('🔍 Form config details:', {
      hasFormConfig: !!formData.form.formConfig,
      serviceTreeExists: !!formData.form.formConfig?.serviceTree,
      serviceTreeChildren: formData.form.formConfig?.serviceTree?.children?.length || 0,
      firstService: formData.form.formConfig?.serviceTree?.children?.[0] ? {
        id: formData.form.formConfig.serviceTree.children[0].id,
        label: formData.form.formConfig.serviceTree.children[0].label,
        type: formData.form.formConfig.serviceTree.children[0].type,
        hasDescription: !!formData.form.formConfig.serviceTree.children[0].description,
        hasPrice: !!formData.form.formConfig.serviceTree.children[0].price,
        hasDuration: !!formData.form.formConfig.serviceTree.children[0].duration,
        description: formData.form.formConfig.serviceTree.children[0].description,
        price: formData.form.formConfig.serviceTree.children[0].price,
        duration: formData.form.formConfig.serviceTree.children[0].duration
      } : null
    })

    return {
      form: formData.form,
      organization: formData.organization,
      service: null // Legacy compatibility
    }
  })

export const validateFormFields = async () => ({ 
  isValid: true, 
  errors: [] 
})